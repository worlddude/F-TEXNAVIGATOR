<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Store Item Locator â€” Client-side GitHub Upload</title>
<style>
body {
  margin: 0;
  font-family: sans-serif;
  background: white;
  color: #111;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}
.header { background: #2563eb; color: white; padding: 10px; display: flex; flex-direction: column; position: relative; }
.search-bar { background: white; border-radius: 6px; padding: 6px 10px; margin-bottom: 0; display: flex; align-items: center; position: relative; }
.search-bar input { border: none; outline: none; flex: 1; font-size: 14px; }
.tabs { display: flex; justify-content: space-around; background: #1e40af; border-radius: 6px; margin-top: 8px; }
.tabs button { flex: 1; background: none; border: none; color: white; padding: 10px; font-size: 14px; transition: background 0.2s; }
.tabs button.active { background: white; color: #2563eb; border-radius: 6px; }
.main { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; overflow: hidden; }
.main.add-tab { justify-content: center; align-items: flex-start; overflow-y: auto; padding: 10px; }
#map { width: 100%; height: 100%; object-fit: cover; display: none; background: white; }
#video { width: 100%; height: 100%; object-fit: cover; display: none; }

/* Item card */
.item-card { background: white; border-radius: 16px 16px 0 0; padding: 16px; box-shadow: 0 -2px 10px rgba(0,0,0,0.2); position: relative; bottom: 0; }
.item-card h2 { margin: 0 0 6px; font-size: 16px; }
.item-card p { margin: 4px 0; font-size: 14px; color: #333; }
button.save { margin-top: 8px; padding: 8px 12px; border: none; border-radius: 8px; background: #2563eb; color: white; font-size: 14px; cursor: pointer; }
#addForm { display: flex; flex-direction: column; gap: 8px; max-width: 400px; width: 90%; margin: auto; background: #f9f9f9; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
#addForm input[type="text"], #addForm input[type="file"] { padding: 6px 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 6px; width: 100%; box-sizing: border-box; }
.item-card.hidden { display: none; }

/* Torch button overlay moved to bottom center */
#torchBtn {
  position: absolute;
  left: 50%;
  bottom: 18px;
  transform: translateX(-50%);
  z-index: 60;
  background: rgba(0,0,0,0.45);
  color: white;
  border: none;
  padding: 12px;
  border-radius: 50%;
  font-size: 18px;
  display: none;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

/* hide the old detect counter UI completely */
#detectBadge { display: none !important; }

/* List Page */
#listPage { width: 100%; max-width: 600px; margin: 0 auto; display: flex; flex-direction: column; gap: 10px; }
.list-item { background: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); cursor: pointer; display: flex; align-items: center; gap: 12px; }
.list-item h3 { margin: 0 0 6px; font-size: 16px; }
.list-item p { margin: 2px 0; font-size: 13px; color: #444; }
.list-thumb { width: 56px; height: 56px; object-fit: cover; border-radius: 8px; background: #f0f0f0; flex: 0 0 56px; }
.load-more { padding: 10px; border-radius: 8px; border: none; background: #1e40af; color: #fff; cursor: pointer; }
.empty { text-align: center; color: #666; padding: 20px; }

/* item-card photo preview */
#itemPhotoDisplay { width: 72px; height: 72px; object-fit: cover; border-radius: 10px; float: right; margin-left: 10px; }
#photoPreview { width: 72px; height: 72px; object-fit: cover; border-radius: 8px; background: #eee; display: block; }
</style>

<script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <form class="search-bar" id="searchForm" autocomplete="off">
      <input type="text" id="searchInput" placeholder="Search for an item or scan a barcode">
    </form>
    <div class="tabs">
      <button id="tab-add">List</button>
      <button id="tab-map" class="active">Map</button>
      <button id="tab-scan">Scan</button>
    </div>
  </div>

  <!-- Map / Camera / List -->
  <div class="main">
    <img id="map" />
    <video id="video" playsinline autoplay muted></video>
    <div id="listPage" style="display:none;"></div>

    <!-- torch toggle button (shown only on scan tab) -->
    <button id="torchBtn" title="Toggle flash">ðŸ”¦</button>
    <div id="detectBadge">0/3</div>
  </div>

  <!-- Item Card for Scan -->
  <div class="item-card" id="itemCard">
    <img id="itemPhotoDisplay" src="" alt="photo" style="display:none;" />
    <h2 id="itemNameDisplay">No item selected</h2>
    <p id="barcodeDisplay">Barcode: -</p>
    <p id="dateDisplay">Date of location: -</p>
    <p id="shelfDisplay">Shelf / Section nr: -</p>
    <div id="addForm" style="display:none; margin-top:10px;">
      <input type="text" id="itemBarcode" placeholder="Barcode" readonly />
      <input type="text" id="itemName" placeholder="Item name" />
      <input type="text" id="itemShelf" placeholder="Shelf number" />
      <input type="text" id="itemSection" placeholder="Section number" />

      <!-- Photo inputs: preview, file upload and hidden data holder -->
      <div style="display:flex; gap:10px; align-items:center;">
        <img id="photoPreview" src="" alt="preview" style="display:none;" />
        <div style="flex:1;">
          <input type="file" id="itemPhotoInput" accept="image/*" />
          <small style="color:#666;">You can replace the captured photo before saving.</small>
          <input type="hidden" id="itemPhotoData" />
        </div>
      </div>

      <button class="save" id="saveBtn">ðŸ’¾ Save Item</button>
    </div>
  </div>

<script>
// DOM Elements
const video = document.getElementById('video');
const mapImg = document.getElementById('map');
const mainDiv = document.querySelector('.main');
const itemCard = document.getElementById('itemCard');
const itemNameDisplay = document.getElementById('itemNameDisplay');
const barcodeDisplay = document.getElementById('barcodeDisplay');
const dateDisplay = document.getElementById('dateDisplay');
const shelfDisplay = document.getElementById('shelfDisplay');
const addForm = document.getElementById('addForm');
const saveBtn = document.getElementById('saveBtn');
const itemNameInput = document.getElementById('itemName');
const itemShelfInput = document.getElementById('itemShelf');
const itemSectionInput = document.getElementById('itemSection');
const itemBarcodeInput = document.getElementById('itemBarcode');
const listPage = document.getElementById('listPage');
const searchForm = document.getElementById('searchForm');
const searchInput = document.getElementById('searchInput');

const torchBtn = document.getElementById('torchBtn');
const detectBadge = document.getElementById('detectBadge');

const tabs = document.querySelectorAll(".tabs button");

const photoPreview = document.getElementById('photoPreview');
const itemPhotoInput = document.getElementById('itemPhotoInput');
const itemPhotoData = document.getElementById('itemPhotoData');
const itemPhotoDisplay = document.getElementById('itemPhotoDisplay');

// DB
let barcodeDB = {};
let currentCode = null;

// Camera / Torch
let currentStream = null;
let torchOn = false;

// Detection confirmation
const CONFIRMATION_THRESHOLD = 3;
let lastDetectedCode = null;
let consecutiveDetectCount = 0;
let acceptCooldown = false; // prevents double-accepts while handling

// paging for list
const PAGE_SIZE = 100;
let lastRenderStart = 0;
let lastRenderedItems = [];

// --- YOUR CONFIG ---
// JSONBin constants (preserve your existing values)
const BIN_ID = "68b57c0543b1c97be932f78d";
const API_KEY = "$2a$10$rDmMHZ2kVWr8MQlJkpRBb.nYegJ2YjslyO0/4sZEpm7HWbCm0Rjvq";

// GITHUB client-side config (VERY SENSITIVE â€” do not publish the token)
// Fill these with your values for client-side upload testing.
const GITHUB_OWNER = "worlddude";     // e.g. "your-github-username"
const GITHUB_REPO  = "F-TEXNAVIGATOR";     // e.g. "your-repo-name"
const GITHUB_BRANCH = "main"; // or your branch
const GITHUB_TOKEN = "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";     // your fine-grained PAT with "Contents: Read & write"
const GITHUB_PHOTO_PATH = "Assets/Item_photo"; // path in repo to store images

// --------------------

function switchTab(tab) {
  tabs.forEach(btn => btn.classList.remove("active"));
  tab.classList.add("active");

  mapImg.style.display = "none";
  video.style.display = "none";
  addForm.style.display = "none";
  listPage.style.display = "none";
  itemCard.classList.add("hidden");
  mainDiv.classList.remove("add-tab");

  // hide detect badge and torch by default
  detectBadge.style.display = "none";
  torchBtn.style.display = "none";

  if(tab.id === "tab-map"){
    mapImg.style.display = "block";
    itemCard.classList.remove("hidden");
    stopCamera();
  } else if(tab.id === "tab-scan"){
    video.style.display = "block";
    itemCard.classList.add("hidden");
    startCamera();
    torchBtn.style.display = "block";
  } else if(tab.id === "tab-add"){
    // List tab
    listPage.style.display = "flex";
    mainDiv.classList.add("add-tab");
    stopCamera();
    const all = getAllItemsArray();
    lastRenderStart = 0;
    renderList(all, lastRenderStart);
  }
}

// Tab click listeners
document.getElementById('tab-map').addEventListener('click', e => switchTab(e.target));
document.getElementById('tab-scan').addEventListener('click', e => switchTab(e.target));
document.getElementById('tab-add').addEventListener('click', e => switchTab(e.target));

// Load DB
async function loadDatabase() {
  try {
    const res = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}/latest`, {
      headers: { "X-Master-Key": API_KEY }
    });
    if (!res.ok) throw new Error("DB not found");
    const data = await res.json();
    barcodeDB = data.record || {};
  } catch (err) {
    console.warn("âš ï¸ Using empty DB:", err);
    barcodeDB = {};
  }
}

function getAllItemsArray() {
  return Object.entries(barcodeDB).map(([barcode, item]) => ({
    barcode,
    name: item.name || '',
    shelf: item.shelf || '',
    section: item.section || '',
    photo: item.photo || item.photoPath || ''
  }));
}

function levenshtein(a, b) {
  if (a === b) return 0;
  if (!a.length) return b.length;
  if (!b.length) return a.length;
  const matrix = [];
  for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
  for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

function renderList(items, startIndex = 0) {
  lastRenderedItems = items;
  lastRenderStart = startIndex;
  listPage.innerHTML = '';
  const end = Math.min(startIndex + PAGE_SIZE, items.length);
  if(items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = 'No items found.';
    listPage.appendChild(empty);
    return;
  }

  for(let i = startIndex; i < end; i++){
    const it = items[i];
    const div = document.createElement('div');
    div.className = 'list-item';
    div.setAttribute('data-barcode', it.barcode);

    const thumbSrc = it.photo ? escapeHtml(it.photo) : '';
    const thumbHTML = thumbSrc ? `<img class="list-thumb" src="${thumbSrc}" alt="thumb" />` : `<div class="list-thumb" style="display:flex;align-items:center;justify-content:center;color:#888;font-size:12px;">No<br>Img</div>`;

    div.innerHTML = `${thumbHTML}
                     <div style="flex:1;">
                       <h3>${escapeHtml(it.name || '-')}</h3>
                       <p>Barcode: ${escapeHtml(it.barcode)}</p>
                       <p>Shelf / Section: ${escapeHtml(it.shelf || '-') } / ${escapeHtml(it.section || '-')}</p>
                     </div>`;

    // click to view on map
    div.addEventListener('click', ()=> {
      const barcode = div.dataset.barcode;
      const item = barcodeDB[barcode];
      if(item){
        if(item.photo){
          itemPhotoDisplay.src = item.photo;
          itemPhotoDisplay.style.display = 'block';
        } else if(item.photoPath){
          itemPhotoDisplay.src = item.photoPath;
          itemPhotoDisplay.style.display = 'block';
        } else {
          itemPhotoDisplay.style.display = 'none';
        }

        itemNameDisplay.textContent = item.name || '-';
        barcodeDisplay.textContent = 'Barcode: ' + barcode;
        dateDisplay.textContent = 'Date of location: ' + new Date().toLocaleDateString();
        shelfDisplay.textContent = 'Shelf / Section nr: ' + (item.shelf || '-') + ' / ' + (item.section || '-');
        switchTab(document.getElementById('tab-map'));
      } else {
        alert('Item not found');
      }
    });

    listPage.appendChild(div);
  }

  if(end < items.length) {
    const btn = document.createElement('button');
    btn.className = 'load-more';
    btn.textContent = 'Load more';
    btn.addEventListener('click', () => {
      renderList(items, end);
    });
    listPage.appendChild(btn);
  }
}

function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/[&<>\"']/g, function(s){
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s];
  });
}

function performSearch() {
  const qRaw = searchInput.value.trim();
  const q = qRaw.toLowerCase();
  const all = getAllItemsArray();
  if(q === ''){
    renderList(all, 0);
    return;
  }

  const results = [];
  for(const it of all){
    const name = (it.name || '').toLowerCase();
    const barcode = (it.barcode || '').toLowerCase();
    let score = 10000;

    if(name === q) score = -1000;
    else if(barcode === q) score = -900;
    else if(name.startsWith(q)) score = -100 + name.indexOf(q);
    else if(barcode.startsWith(q)) score = -50 + barcode.indexOf(q);
    else if(name.includes(q)) score = 10 + name.indexOf(q);
    else if(barcode.includes(q)) score = 20 + barcode.indexOf(q);
    else if((it.shelf || '').toLowerCase().includes(q) || (it.section || '').toLowerCase().includes(q)) score = 200;
    else {
      const levName = levenshtein(q, name);
      const maxAllowed = Math.max(2, Math.floor(name.length * 0.25));
      if(name && levName <= maxAllowed) score = 50 + levName;
      else {
        const levBarcode = levenshtein(q, barcode);
        const maxAllowedBar = Math.max(1, Math.floor(barcode.length * 0.15));
        if(barcode && levBarcode <= maxAllowedBar) score = 60 + levBarcode;
      }
    }

    if(score < 10000) results.push({it, score});
  }

  if(results.length === 0){
    for(const it of all){
      const hay = ((it.name||'') + ' ' + (it.barcode||'') + ' ' + (it.shelf||'') + ' ' + (it.section||'')).toLowerCase();
      if(hay.includes(q)) {
        results.push({it, score: 500 + hay.indexOf(q)});
      }
    }
  }

  results.sort((a,b)=> a.score - b.score);
  const items = results.map(r=>r.it);
  renderList(items, 0);
}

searchForm.addEventListener('submit', (e)=>{
  e.preventDefault();
  switchTab(document.getElementById('tab-add'));
  performSearch();
});

let debounceTimer = null;
searchInput.addEventListener('input', ()=>{
  switchTab(document.getElementById('tab-add'));
  if(debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(()=>{
    performSearch();
    debounceTimer = null;
  }, 150);
});

searchInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    switchTab(document.getElementById('tab-add'));
    performSearch();
  }
});

// ---------------------------
// Client-side save/upload code
// ---------------------------

// Save to JSONBin and error-check
async function saveToDatabase(newCode, newItem) {
  barcodeDB[newCode] = newItem;
  const res = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", "X-Master-Key": API_KEY },
    body: JSON.stringify(barcodeDB, null, 2)
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error('JSONBin save failed: ' + res.status + ' ' + txt);
  }
  try { return await res.json(); } catch(e) { return null; }
}

// dataURL -> base64 portion
function dataURLtoBase64(dataURL) {
  const idx = dataURL.indexOf('base64,');
  if (idx === -1) return null;
  return dataURL.substring(idx + 7);
}

// Upload to GitHub (client-side). Returns raw.githubusercontent URL.
async function uploadToGitHub(barcode, dataURL) {
  if (!GITHUB_OWNER || !GITHUB_REPO || !GITHUB_TOKEN) {
    throw new Error('GitHub config missing');
  }
  const path = `${GITHUB_PHOTO_PATH}/${barcode}.png`;
  const apiUrl = `https://api.github.com/repos/${encodeURIComponent(GITHUB_OWNER)}/${encodeURIComponent(GITHUB_REPO)}/contents/${encodeURIComponent(path)}`;

  const contentBase64 = dataURLtoBase64(dataURL);
  if (!contentBase64) throw new Error('Invalid image data');

  // Try GET to obtain sha if file exists (so we can update)
  let sha = null;
  try {
    const getRes = await fetch(apiUrl + `?ref=${encodeURIComponent(GITHUB_BRANCH)}`, {
      headers: { Authorization: `Bearer ${GITHUB_TOKEN}`, Accept: 'application/vnd.github+json' }
    });
    if (getRes.ok) {
      const json = await getRes.json();
      if (json && json.sha) sha = json.sha;
    }
  } catch (err) {
    console.warn('GitHub GET failed (maybe not exists):', err);
  }

  const body = {
    message: `Add/update photo for ${barcode}`,
    content: contentBase64,
    branch: GITHUB_BRANCH
  };
  if (sha) body.sha = sha;

  const putRes = await fetch(apiUrl, {
    method: 'PUT',
    headers: { Authorization: `Bearer ${GITHUB_TOKEN}`, Accept: 'application/vnd.github+json', 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });

  if (!putRes.ok) {
    const txt = await putRes.text();
    throw new Error('GitHub upload failed: ' + putRes.status + ' ' + txt);
  }

  // raw url
  return `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${path}`;
}

// helper: capture current video frame to data URL
function captureFrameDataURL() {
  try {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth || 640;
    canvas.height = video.videoHeight || 480;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png');
  } catch (e) {
    console.warn('Failed to capture frame:', e);
    return null;
  }
}

// when a file is selected, read it into hidden data input & preview
itemPhotoInput.addEventListener('change', (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    const data = ev.target.result;
    itemPhotoData.value = data;
    photoPreview.src = data;
    photoPreview.style.display = 'block';
  };
  reader.readAsDataURL(f);
});

// Barcode scanner with multi-detection confirmation
function startScanner() {
  lastDetectedCode = null;
  consecutiveDetectCount = 0;
  acceptCooldown = false;
  detectBadge.textContent = `0/${CONFIRMATION_THRESHOLD}`;

  Quagga.init({
    inputStream: { name: 'Live', type: 'LiveStream', target: video },
    decoder: { readers: ['ean_reader','upc_reader','code_128_reader'] },
    locate: true
  }, err => {
    if(err) {
      console.error(err);
      return;
    }
    Quagga.start();
  });

  Quagga.onDetected(result => {
    if (!result || !result.codeResult) return;
    const code = result.codeResult.code;
    if (acceptCooldown) return;

    if (lastDetectedCode === code) consecutiveDetectCount++;
    else { lastDetectedCode = code; consecutiveDetectCount = 1; }

    if (consecutiveDetectCount >= CONFIRMATION_THRESHOLD) {
      acceptCooldown = true;
      lastDetectedCode = null;
      consecutiveDetectCount = 0;
      detectBadge.textContent = `0/${CONFIRMATION_THRESHOLD}`;

      currentCode = code;
      const item = barcodeDB[code];
      if(item){
        if(item.photo){
          itemPhotoDisplay.src = item.photo;
          itemPhotoDisplay.style.display = 'block';
        } else if(item.photoPath){
          itemPhotoDisplay.src = item.photoPath;
          itemPhotoDisplay.style.display = 'block';
        } else {
          itemPhotoDisplay.style.display = 'none';
        }

        itemNameDisplay.textContent = item.name;
        barcodeDisplay.textContent = "Barcode: " + code;
        dateDisplay.textContent = "Date of location: " + new Date().toLocaleDateString();
        shelfDisplay.textContent = "Shelf / Section nr: " + item.shelf + " / " + item.section;
        switchTab(document.getElementById('tab-map'));
      } else {
        itemNameDisplay.textContent = "âŒ Not found in database";
        barcodeDisplay.textContent = "Barcode: " + code;
        dateDisplay.textContent = "Date of location: -";
        shelfDisplay.textContent = "";
        itemBarcodeInput.value = code;

        // capture frame for preview
        const dataURL = captureFrameDataURL();
        if(dataURL){
          itemPhotoData.value = dataURL;
          photoPreview.src = dataURL;
          photoPreview.style.display = 'block';
        } else {
          itemPhotoData.value = '';
          photoPreview.style.display = 'none';
        }

        video.style.display = "none";
        addForm.style.display = "flex";
        itemCard.classList.remove("hidden");
        stopCamera();
      }

      setTimeout(()=> { acceptCooldown = false; }, 700);
    }
  });
}

function stopCamera() {
  acceptCooldown = false;
  lastDetectedCode = null;
  consecutiveDetectCount = 0;
  detectBadge.style.display = "none";
  torchBtn.style.display = "none";

  if (currentStream) {
    currentStream.getTracks().forEach(track => track.stop());
    currentStream = null;
  }
  if (video.srcObject) {
    try { video.srcObject.getTracks().forEach(t => t.stop()); } catch(e){}
    video.srcObject = null;
  }
  if (window.Quagga) {
    try { Quagga.stop(); } catch (e) {}
  }
}

async function startCamera() {
  acceptCooldown = false;
  lastDetectedCode = null;
  consecutiveDetectCount = 0;
  detectBadge.textContent = `0/${CONFIRMATION_THRESHOLD}`;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    currentStream = stream;
    video.srcObject = stream;
    video.play().catch(()=>{});
    torchOn = false;
    startScanner();
  } catch (err) {
    alert('Error accessing camera: ' + err.message);
  }
}

// Torch control
async function toggleTorch() {
  if (!currentStream) {
    alert('Camera not started');
    return;
  }
  const track = currentStream.getVideoTracks()[0];
  if (!track) {
    alert('No video track available');
    return;
  }
  const capabilities = track.getCapabilities ? track.getCapabilities() : {};
  if (!capabilities || !capabilities.torch) {
    try {
      await track.applyConstraints({ advanced: [{ torch: !torchOn }] });
      torchOn = !torchOn;
      torchBtn.textContent = torchOn ? 'ðŸ”¦' : 'ðŸ”¦';
    } catch (err) {
      alert('Torch not supported on this device/browser.');
    }
    return;
  }
  try {
    await track.applyConstraints({ advanced: [{ torch: !torchOn }] });
    torchOn = !torchOn;
    torchBtn.style.background = torchOn ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.45)';
    torchBtn.style.color = torchOn ? '#111' : 'white';
  } catch (err) {
    console.warn('Torch toggle failed:', err);
    alert('Failed to toggle torch: ' + err.message);
  }
}

torchBtn.addEventListener('click', toggleTorch);

// ---------------------------
// Save button handler (client-side flow)
// ---------------------------
// helper: resize/compress a dataURL (returns a JPEG dataURL)
async function resizeDataURL(dataURL, maxWidth = 1024, quality = 0.75) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const scale = Math.min(1, maxWidth / img.width);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      try {
        const jpegDataUrl = canvas.toDataURL('image/jpeg', quality);
        resolve(jpegDataUrl);
      } catch (err) {
        reject(err);
      }
    };
    img.onerror = () => reject(new Error('Failed to load image for resize'));
    img.crossOrigin = 'anonymous';
    img.src = dataURL;
  });
}

// NEW save handler: upload photo to GitHub first, then save small JSON to JSONBin
saveBtn.addEventListener("click", async () => {
  try {
    const name = itemNameInput.value.trim();
    const shelf = itemShelfInput.value.trim();
    const section = itemSectionInput.value.trim();
    const barcode = itemBarcodeInput.value.trim();
    if (!name || !shelf || !section || !barcode) {
      alert("Please fill all fields");
      return;
    }

    // Step 1: get photo (base64 dataURL) if present
    const inlinePhoto = itemPhotoData.value || null;

    // Step 2: If there's a photo, compress/resize it first (reduces upload size)
    let uploadDataURL = null;
    if (inlinePhoto) {
      try {
        // reduce to at most 1024px width, jpeg quality 0.75
        uploadDataURL = await resizeDataURL(inlinePhoto, 1024, 0.75);
      } catch (err) {
        console.warn('Resize failed â€” falling back to original photo', err);
        uploadDataURL = inlinePhoto;
      }
    }

    // Step 3: If we have image data and GitHub is configured, upload to GitHub first
    let finalPhotoPath = null;
    if (uploadDataURL && GITHUB_TOKEN && GITHUB_OWNER && GITHUB_REPO) {
      try {
        // uploadToGitHub should exist in your code and return the raw.githubusercontent URL
        finalPhotoPath = await uploadToGitHub(barcode, uploadDataURL);
      } catch (ghErr) {
        console.error('GitHub upload failed:', ghErr);
        alert('Image upload to GitHub failed: ' + ghErr.message + '\nSave aborted to avoid JSONBin exceeding size limits.');
        return;
      }
    }

    // Step 4: Build small metadata object (do NOT include large inline base64)
    const itemToSave = {
      name,
      shelf,
      section,
      photoPath: finalPhotoPath || `/assets/Item_photo/${barcode}.png`
    };

    // Step 5: Save small JSON to JSONBin (this should be <100KB)
    await saveToDatabase(barcode, itemToSave);

    // Step 6: Refresh DB and update UI
    await loadDatabase();
    const saved = barcodeDB[barcode];
    if (saved) {
      if (saved.photoPath) {
        itemPhotoDisplay.src = saved.photoPath;
        itemPhotoDisplay.style.display = 'block';
      } else {
        itemPhotoDisplay.style.display = 'none';
      }
      itemNameDisplay.textContent = saved.name || name;
      shelfDisplay.textContent = "Shelf / Section nr: " + (saved.shelf || shelf) + " / " + (saved.section || section);
    }

    addForm.style.display = "none";
    switchTab(document.getElementById('tab-map'));
    alert('Item saved successfully.');

  } catch (err) {
    console.error('Save failed:', err);
    alert('Save failed: ' + err.message);
  }
});
  
// Init
mapImg.style.display = "block";
window.addEventListener('load', async ()=>{ await loadDatabase(); });
</script>
</body>
</html>




