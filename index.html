<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Store Item Locator â€” Updated (fuzzy + click-to-map)</title>
<style>
body {
  margin: 0;
  font-family: sans-serif;
  background: white;
  color: #111;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}
.header { background: #2563eb; color: white; padding: 10px; display: flex; flex-direction: column; position: relative; }
.search-bar { background: white; border-radius: 6px; padding: 6px 10px; margin-bottom: 0; display: flex; align-items: center; position: relative; }
.search-bar input { border: none; outline: none; flex: 1; font-size: 14px; }
.tabs { display: flex; justify-content: space-around; background: #1e40af; border-radius: 6px; margin-top: 8px; }
.tabs button { flex: 1; background: none; border: none; color: white; padding: 10px; font-size: 14px; transition: background 0.2s; }
.tabs button.active { background: white; color: #2563eb; border-radius: 6px; }
.main { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; overflow: hidden; }
.main.add-tab { justify-content: center; align-items: flex-start; overflow-y: auto; padding: 10px; }

/* map container so we can absolutely position markers on top of the image */
#mapWrap { position: relative; width: 100%; height: 100%; display: none; background: white; overflow: hidden; }
#map { width: 100%; height: 100%; object-fit: contain; display: block; user-select: none; -webkit-user-drag: none; }

.map-marker {
  position: absolute;
  width: 28px;
  height: 28px;
  transform: translate(-50%, -100%); /* center bottom of the marker on the click point */
  pointer-events: none;
  z-index: 10;
  display: none;
}
.map-marker .pin {
  width: 28px;
  height: 28px;
  border-radius: 50% 50% 50% 50%;
  background: #ef4444; /* red pin */
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  border: 2px solid white;
  transform: scale(1);
}
.map-marker .pin::after {
  content: '';
  position: absolute;
  left: 50%;
  top: 100%;
  transform: translate(-50%, -2px);
  width: 8px;
  height: 8px;
  background: rgba(0,0,0,0.15);
  border-radius: 50%;
  filter: blur(2px);
}

/* show marker with a small appear animation */
.map-marker.show { display: block; animation: pop 160ms ease; }
@keyframes pop { from { transform: translate(-50%, -100%) scale(0.8); opacity: 0 } to { transform: translate(-50%, -100%) scale(1); opacity: 1 } }

#video { width: 100%; height: 100%; object-fit: cover; display: none; }
.item-card { background: white; border-radius: 16px 16px 0 0; padding: 16px; box-shadow: 0 -2px 10px rgba(0,0,0,0.2); position: relative; bottom: 0; }
.item-card h2 { margin: 0 0 6px; font-size: 16px; }
.item-card p { margin: 4px 0; font-size: 14px; color: #333; }
button.save { margin-top: 8px; padding: 8px 12px; border: none; border-radius: 8px; background: #2563eb; color: white; font-size: 14px; cursor: pointer; }
#addForm { display: flex; flex-direction: column; gap: 8px; max-width: 400px; width: 90%; margin: auto; background: #f9f9f9; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
#addForm input { padding: 6px 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 6px; width: 100%; box-sizing: border-box; }
.item-card.hidden { display: none; }
/* List Page */
#listPage { width: 100%; max-width: 600px; margin: 0 auto; display: flex; flex-direction: column; gap: 10px; }
.list-item { background: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); cursor: pointer; }
.list-item h3 { margin: 0 0 6px; font-size: 16px; }
.list-item p { margin: 2px 0; font-size: 13px; color: #444; }
.load-more { padding: 10px; border-radius: 8px; border: none; background: #1e40af; color: #fff; cursor: pointer; }
.empty { text-align: center; color: #666; padding: 20px; }

/* small hint text near map */
.map-hint {
  position: absolute;
  top: 10px;
  left: 12px;
  z-index: 20;
  background: rgba(255,255,255,0.9);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 13px;
  color: #111;
  box-shadow: 0 1px 6px rgba(0,0,0,0.08);
}
</style>

<script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <form class="search-bar" id="searchForm" autocomplete="off">
      <input type="text" id="searchInput" placeholder="Search for an item or scan a barcode">
    </form>
    <div class="tabs">
      <button id="tab-add">List</button>
      <button id="tab-map" class="active">Map</button>
      <button id="tab-scan">Scan</button>
    </div>
  </div>

  <!-- Map / Camera / List -->
  <div class="main">
    <!-- map wrapped so we can place markers on top -->
    <div id="mapWrap">
      <div class="map-hint">Click on the map to place a pin for the selected item</div>
      <img id="map" alt="Store map" draggable="false" />
      <div id="marker" class="map-marker" title="Item location">
        <div class="pin"></div>
      </div>
    </div>

    <video id="video" playsinline autoplay muted></video>
    <div id="listPage" style="display:none;"></div>
  </div>

  <!-- Item Card for Scan -->
  <div class="item-card" id="itemCard">
    <h2 id="itemNameDisplay">No item selected</h2>
    <p id="barcodeDisplay">Barcode: -</p>
    <p id="dateDisplay">Date of location: -</p>
    <p id="shelfDisplay">Shelf / Section nr: -</p>
    <div id="addForm" style="display:none; margin-top:10px;">
      <input type="text" id="itemBarcode" placeholder="Barcode" readonly />
      <input type="text" id="itemName" placeholder="Item name" />
      <input type="text" id="itemShelf" placeholder="Shelf number" />
      <input type="text" id="itemSection" placeholder="Section number" />
      <button class="save" id="saveBtn">ðŸ’¾ Save Item</button>
    </div>
  </div>

<script>
// DOM Elements
const video = document.getElementById('video');
const mapImg = document.getElementById('map');
const mapWrap = document.getElementById('mapWrap');
const marker = document.getElementById('marker');
const mainDiv = document.querySelector('.main');
const itemCard = document.getElementById('itemCard');
const itemNameDisplay = document.getElementById('itemNameDisplay');
const barcodeDisplay = document.getElementById('barcodeDisplay');
const dateDisplay = document.getElementById('dateDisplay');
const shelfDisplay = document.getElementById('shelfDisplay');
const addForm = document.getElementById('addForm');
const saveBtn = document.getElementById('saveBtn');
const itemNameInput = document.getElementById('itemName');
const itemShelfInput = document.getElementById('itemShelf');
const itemSectionInput = document.getElementById('itemSection');
const itemBarcodeInput = document.getElementById('itemBarcode');
const listPage = document.getElementById('listPage');
const searchForm = document.getElementById('searchForm');
const searchInput = document.getElementById('searchInput');

const tabs = document.querySelectorAll(".tabs button");

// DB
let barcodeDB = {};
let currentCode = null;

// paging for list
const PAGE_SIZE = 100; // max 100 at a time
let lastRenderStart = 0;
let lastRenderedItems = [];

/* ---------- MAP URL ----------
   Update this if your image is hosted elsewhere.
   Examples:
   - If using GitHub Pages (username.github.io/repo): "/repo/Assets/Map.png"
   - If using raw GitHub content: "https://raw.githubusercontent.com/USERNAME/REPO/BRANCH/Assets/Map.png"
*/
const MAP_URL = './Assets/Map.png'; // <-- change this path if needed

// Switch Tab Function
function switchTab(tab) {
  tabs.forEach(btn => btn.classList.remove("active"));
  tab.classList.add("active");

  mapWrap.style.display = "none";
  video.style.display = "none";
  addForm.style.display = "none";
  listPage.style.display = "none";
  itemCard.classList.add("hidden");
  mainDiv.classList.remove("add-tab");

  if(tab.id === "tab-map"){
    mapWrap.style.display = "block";
    itemCard.classList.remove("hidden");
    stopCamera();
  } else if(tab.id === "tab-scan"){
    video.style.display = "block";
    itemCard.classList.add("hidden");
    startCamera();
  } else if(tab.id === "tab-add"){
    // List tab
    listPage.style.display = "flex";
    mainDiv.classList.add("add-tab");
    stopCamera();
    // Render first page of items if available
    const all = getAllItemsArray();
    lastRenderStart = 0;
    renderList(all, lastRenderStart);
  }
}

// Tab click listeners
document.getElementById('tab-map').addEventListener('click', e => switchTab(e.target));
document.getElementById('tab-scan').addEventListener('click', e => switchTab(e.target));
document.getElementById('tab-add').addEventListener('click', e => switchTab(e.target));

// Load DB
async function loadDatabase() {
  try {
    const res = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}/latest`, {
      headers: { "X-Master-Key": API_KEY }
    });
    if (!res.ok) throw new Error("DB not found");
    const data = await res.json();
    barcodeDB = data.record || {};
  } catch (err) {
    console.warn("âš ï¸ Using empty DB:", err);
    barcodeDB = {};
  }
}

function getAllItemsArray() {
  return Object.entries(barcodeDB).map(([barcode, item]) => ({ barcode, name: item.name || '', shelf: item.shelf || '', section: item.section || '' }));
}

// Levenshtein distance for fuzzy matching
function levenshtein(a, b) {
  if (a === b) return 0;
  if (!a.length) return b.length;
  if (!b.length) return a.length;
  const matrix = [];
  // increment along the first column of each row
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  // increment each column in the first row
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  // Fill in the rest of the matrix
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1,     // insertion
          matrix[i - 1][j] + 1      // deletion
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

// Render list (with paging)
function renderList(items, startIndex = 0) {
  lastRenderedItems = items;
  lastRenderStart = startIndex;
  listPage.innerHTML = '';
  const end = Math.min(startIndex + PAGE_SIZE, items.length);
  if(items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = 'No items found.';
    listPage.appendChild(empty);
    return;
  }

  for(let i = startIndex; i < end; i++){
    const it = items[i];
    const div = document.createElement('div');
    div.className = 'list-item';
    div.setAttribute('data-barcode', it.barcode);
    div.innerHTML = `<h3>${escapeHtml(it.name || '-')}</h3>
                     <p>Barcode: ${escapeHtml(it.barcode)}</p>
                     <p>Shelf / Section: ${escapeHtml(it.shelf || '-') } / ${escapeHtml(it.section || '-')}</p>`;
    // click to view on map
    div.addEventListener('click', ()=>{
      const barcode = div.dataset.barcode;
      const item = barcodeDB[barcode];
      if(item){
        currentCode = barcode;
        itemNameDisplay.textContent = item.name || '-';
        barcodeDisplay.textContent = 'Barcode: ' + barcode;
        dateDisplay.textContent = 'Date of location: ' + new Date().toLocaleDateString();
        shelfDisplay.textContent = 'Shelf / Section nr: ' + (item.shelf || '-') + ' / ' + (item.section || '-');
        // show marker for item if coordinates exist
        if(item.map && typeof item.map.x === 'number' && typeof item.map.y === 'number'){
          placeMarker(item.map.x, item.map.y);
        } else {
          hideMarker();
        }
        // switch to map tab
        switchTab(document.getElementById('tab-map'));
      } else {
        alert('Item not found');
      }
    });

    listPage.appendChild(div);
  }

  // Load more button if there are more
  if(end < items.length) {
    const btn = document.createElement('button');
    btn.className = 'load-more';
    btn.textContent = 'Load more';
    btn.addEventListener('click', () => {
      renderList(items, end);
    });
    listPage.appendChild(btn);
  }
}

// Simple HTML escape
function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/[&<>\"']/g, function(s){
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s];
  });
}

// Search logic â€” scores and sorts best matches first (now includes Levenshtein fuzzy matching)
function performSearch() {
  const qRaw = searchInput.value.trim();
  const q = qRaw.toLowerCase();
  const all = getAllItemsArray();
  if(q === ''){
    // show first page of all items
    renderList(all, 0);
    return;
  }

  const results = [];
  for(const it of all){
    const name = (it.name || '').toLowerCase();
    const barcode = (it.barcode || '').toLowerCase();
    let score = 10000;

    // high-priority exact matches
    if(name === q) score = -1000;
    else if(barcode === q) score = -900;
    // startsWith is good
    else if(name.startsWith(q)) score = -100 + name.indexOf(q);
    else if(barcode.startsWith(q)) score = -50 + barcode.indexOf(q);
    // substring matches
    else if(name.includes(q)) score = 10 + name.indexOf(q);
    else if(barcode.includes(q)) score = 20 + barcode.indexOf(q);
    // shelf/section match
    else if((it.shelf || '').toLowerCase().includes(q) || (it.section || '').toLowerCase().includes(q)) score = 200;
    else {
      // fuzzy via Levenshtein (allow small relative distance)
      const levName = levenshtein(q, name);
      const maxAllowed = Math.max(2, Math.floor(name.length * 0.25));
      if(name && levName <= maxAllowed) score = 50 + levName; // smaller distance => better
      else {
        const levBarcode = levenshtein(q, barcode);
        const maxAllowedBar = Math.max(1, Math.floor(barcode.length * 0.15));
        if(barcode && levBarcode <= maxAllowedBar) score = 60 + levBarcode;
      }
    }

    if(score < 10000) results.push({it, score});
  }

  // If no direct results found by the filters above, try a relaxed includes search across all fields (fallback)
  if(results.length === 0){
    for(const it of all){
      const hay = ((it.name||'') + ' ' + (it.barcode||'') + ' ' + (it.shelf||'') + ' ' + (it.section||'')).toLowerCase();
      if(hay.includes(q)) {
        results.push({it, score: 500 + hay.indexOf(q)});
      }
    }
  }

  // sort by score (lower is better)
  results.sort((a,b)=> a.score - b.score);
  const items = results.map(r=>r.it);
  renderList(items, 0);
}

// Prevent form from submitting / pressing Enter causing navigation or map-switch
searchForm.addEventListener('submit', (e)=>{
  e.preventDefault();
  // keep focus in the search field and show results
  switchTab(document.getElementById('tab-add'));
  performSearch();
});

// When typing: switch to list tab and show best matches (debounce lightly)
let debounceTimer = null;
searchInput.addEventListener('input', ()=>{
  // immediately switch to list tab (user requested behavior)
  switchTab(document.getElementById('tab-add'));
  if(debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(()=>{
    performSearch();
    debounceTimer = null;
  }, 150);
});

// Also make sure Enter key doesn't trigger unexpected behavior
searchInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    // show results and keep user on list
    switchTab(document.getElementById('tab-add'));
    performSearch();
  }
});

// Save to DB
async function saveToDatabase(newCode, newItem) {
  barcodeDB[newCode] = newItem;
  await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", "X-Master-Key": API_KEY },
    body: JSON.stringify(barcodeDB, null, 2)
  });
}

/* ---------- Map helpers ---------- */
function placeMarker(xPct, yPct) {
  // xPct and yPct are numbers [0..1]
  if(typeof xPct !== 'number' || typeof yPct !== 'number') return;
  // convert to pixels relative to mapWrap
  const rect = mapImg.getBoundingClientRect();
  // if image hasn't been laid out yet, do a retry shortly
  if(rect.width === 0 || rect.height === 0) {
    setTimeout(()=>placeMarker(xPct, yPct), 60);
    return;
  }
  // compute absolute position based on image visible area inside mapWrap
  // We assume the img covers the whole mapWrap area (object-fit: contain) so we must account for letterboxing
  const wrapRect = mapWrap.getBoundingClientRect();
  const imgAspect = mapImg.naturalWidth && mapImg.naturalHeight ? mapImg.naturalWidth / mapImg.naturalHeight : rect.width / rect.height;
  const wrapAspect = wrapRect.width / wrapRect.height;
  let imgLeft = rect.left;
  let imgTop = rect.top;
  let imgWidth = rect.width;
  let imgHeight = rect.height;

  // absolute coordinates (client)
  const clientX = imgLeft + xPct * imgWidth;
  const clientY = imgTop + yPct * imgHeight;

  // position marker relative to mapWrap (use percent)
  const leftPercent = ((clientX - wrapRect.left) / wrapRect.width) * 100;
  const topPercent = ((clientY - wrapRect.top) / wrapRect.height) * 100;

  marker.style.left = leftPercent + '%';
  marker.style.top = topPercent + '%';
  marker.classList.add('show');
  marker.style.display = 'block';
}

function hideMarker() {
  marker.classList.remove('show');
  marker.style.display = 'none';
}

/* Clicking on the map: place marker and optionally save to current item */
mapImg.addEventListener('click', async (e) => {
  const rect = mapImg.getBoundingClientRect();
  if(rect.width === 0 || rect.height === 0) return;
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  // clamp
  const xPct = Math.max(0, Math.min(1, x));
  const yPct = Math.max(0, Math.min(1, y));
  placeMarker(xPct, yPct);

  // if a current item is selected (existing in DB), save coordinates
  if(currentCode && barcodeDB[currentCode]) {
    barcodeDB[currentCode].map = { x: xPct, y: yPct };
    // persist immediately
    try {
      await saveToDatabase(currentCode, barcodeDB[currentCode]);
      // update display
      shelfDisplay.textContent = 'Shelf / Section nr: ' + (barcodeDB[currentCode].shelf || '-') + ' / ' + (barcodeDB[currentCode].section || '-')
        + `  (map: ${Math.round(xPct*100)}%, ${Math.round(yPct*100)}%)`;
    } catch (err) {
      console.error('Error saving map position:', err);
      alert('Failed to save location to DB.');
    }
    return;
  }

  // if user is in "add form" mode (adding new item), fill shelf/section with coordinates as helper
  if(addForm.style.display !== 'none') {
    itemShelfInput.value = Math.round(xPct * 100); // e.g., percent as shelf placeholder
    itemSectionInput.value = Math.round(yPct * 100);
    // keep add form visible â€” user still needs to press Save
  }
});

// place marker for item (if it has saved map coords)
function showMarkerForItem(item) {
  if(item && item.map && typeof item.map.x === 'number' && typeof item.map.y === 'number'){
    placeMarker(item.map.x, item.map.y);
  } else {
    hideMarker();
  }
}

/* ---------- Camera Control ---------- */
function stopCamera() {
  if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());
  video.srcObject = null;
  if (Quagga) try{ Quagga.stop(); } catch(e){}
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    video.srcObject = stream;
    startScanner();
  } catch (err) {
    alert('Error accessing camera: ' + err.message);
  }
}

// Barcode scanner
function startScanner() {
  Quagga.init({
    inputStream: { name: 'Live', type: 'LiveStream', target: video },
    decoder: { readers: ['ean_reader','upc_reader','code_128_reader'] }
  }, err => { if(err) console.error(err); else Quagga.start(); });

  Quagga.onDetected(result => {
    const code = result.codeResult.code;
    currentCode = code;
    const item = barcodeDB[code];
    if(item){
      itemNameDisplay.textContent = item.name;
      barcodeDisplay.textContent = "Barcode: " + code;
      dateDisplay.textContent = "Date of location: " + new Date().toLocaleDateString();
      shelfDisplay.textContent = "Shelf / Section nr: " + (item.shelf || '-') + " / " + (item.section || '-');
      // show marker if item has coordinates
      showMarkerForItem(item);
      switchTab(document.getElementById('tab-map'));
    } else {
      itemNameDisplay.textContent = "âŒ Not found in database";
      barcodeDisplay.textContent = "Barcode: " + code;
      dateDisplay.textContent = "Date of location: -";
      shelfDisplay.textContent = "";
      itemBarcodeInput.value = code;
      video.style.display = "none";
      addForm.style.display = "flex";
      itemCard.classList.remove("hidden");
      stopCamera();
    }
  });
}

// Save new item
saveBtn.addEventListener("click", async () => {
  const name = itemNameInput.value.trim();
  const shelf = itemShelfInput.value.trim();
  const section = itemSectionInput.value.trim();
  const barcode = itemBarcodeInput.value.trim();
  if(!name || !shelf || !section || !barcode){
    alert("Please fill all fields");
    return;
  }
  const newItem = { name, shelf, section };
  // if a marker exists and currentCode matches this barcode, keep map coordinates
  if(currentCode === barcode && barcodeDB[barcode] && barcodeDB[barcode].map) {
    newItem.map = barcodeDB[barcode].map;
  }
  await saveToDatabase(barcode,newItem);
  barcodeDB[barcode] = newItem;
  currentCode = barcode;
  itemNameDisplay.textContent = name;
  shelfDisplay.textContent = "Shelf / Section nr: " + shelf + " / " + section;
  addForm.style.display = "none";
  // show marker if present
  showMarkerForItem(newItem);
});

// Init - load map image
mapImg.style.display = "block";
mapImg.src = MAP_URL;
mapImg.addEventListener('load', ()=> {
  // nothing special needed, marker placement will calculate using sizes later
});
mapImg.addEventListener('error', ()=>{
  console.warn('Failed to load map image at', MAP_URL);
  // If you see this, set MAP_URL to the correct path (GitHub raw or GitHub Pages path)
  // Example raw GitHub URL:
  // const MAP_URL = "https://raw.githubusercontent.com/USERNAME/REPO/BRANCH/Assets/Map.png";
});

// Constants for DB access (preserve your existing values)
const BIN_ID = "68b57c0543b1c97be932f78d"; 
const API_KEY = "$2a$10$rDmMHZ2kVWr8MQlJkpRBb.nYegJ2YjslyO0/4sZEpm7HWbCm0Rjvq";

window.addEventListener('load', async ()=>{
  await loadDatabase();
  // if you have a currently-selected code (e.g., persisted elsewhere), show it; otherwise hide marker
  hideMarker();
});
</script>
</body>
</html>
